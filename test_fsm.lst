                  2   $LIST
0000              4   
0000              5   ;  N76E003 pinout:
0000              6   ;                               -------
0000              7   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              8   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000              9   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             10   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             11   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             12   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             13   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             14   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             15   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             16   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             17   ;                               -------
0000             18   ;
0000             19   
0000             20   CLK           EQU 16600000 ; Microcontroller system frequency in Hz
0000             21   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000             22   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             23   
0000             24   START_BUTTON equ P1.7
0000             25   OUTPUT_PIN        equ P1.5
0000             26   
0000             27   ; Reset vector
0000             28   org 0x0000
0000 020292      29       ljmp FSM_main
0003             30   
0003             31   ; External interrupt 0 vector (not used in this code)
0003             32   org 0x0003
0003 32          33            reti
0004             34   
0004             35   ; Timer/Counter 0 overflow interrupt vector
000B             36   org 0x000B
000B 32          37            reti
000C             38   
000C             39   ; External interrupt 1 vector (not used in this code)
0013             40   org 0x0013
0013 32          41            reti
0014             42   
0014             43   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             44   org 0x001B
001B 32          45            reti
001C             46   
001C             47   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             48   org 0x0023 
0023 32          49            reti
0024             50            
0024             51   ; Timer/Counter 2 overflow interrupt vector
002B             52   org 0x002B
002B 020129      53            ljmp Timer2_ISR
002E             54   
0030             55   dseg at 0x30
0030             56   Count1ms:     ds 2 ; Used to determine when half second has passed
0032             57   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033             58   STATE_NUM:         ds 1 ;
0034             59   Current_Counter:           ds 1 ; 
0035             60   Resulting_Counter:         ds 1 ;
0036             61   timer_state:          ds 1 ;
0037             62   beep_count:                        ds 1 ;
0038             63   desired_PWM:               ds 2 ;
003A             64   
003A             65   
003A             66   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
003A             67   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             68   bseg
0000             69   ;Alarm_En_Flag:  dbit 1
0000             70   ;timer_state:            dbit 1 ; is state in a timer state?
0000             71   
002E             72   cseg
002E             73   ; These 'equ' must match the hardware wiring
002E             74   LCD_RS equ P1.3
002E             75   LCD_E  equ P1.4
002E             76   LCD_D4 equ P0.0
002E             77   LCD_D5 equ P0.1
002E             78   LCD_D6 equ P0.2
002E             79   LCD_D7 equ P0.3
002E             80   
002E             81   
                 84   $LIST
00E2             86   
00E2             87   pwm_main: ; called in main
00E2             88       ;initial values, STARTING AT state0
00E2 753800      89       mov desired_PWM, #0x00      ;set desired PWM percent to 0
00E5             90       ;setb OUTPUT_PIN             ;
00E5 22          91       ret
00E6             92   
00E6             93   
00E6             94   
00E6             95   Inc_PWM: ; called from fsm.asm
00E6 E530        96            mov a, Count1ms+0
00E8 B53807      97       cjne a, desired_PWM+0, Inc_PWM2 
00EB E531        98            mov a, Count1ms+1
00ED B53902      99            cjne a, desired_PWM+1, Inc_PWM2
00F0 C295       100       clr OUTPUT_PIN
00F2            101   Inc_PWM2:
00F2 E530       102       mov a, Count1ms+0
00F4 B4E707     103       cjne a, #low(999), return0 
00F7 E531       104            mov a, Count1ms+1
00F9 B40302     105            cjne a, #high(999), return0
00FC D295       106       setb OUTPUT_PIN  ;NOTE: unsure if swap power flag needed
00FE            107   return0:
00FE 22         108            ret
00FF            109   
00FF            110   
00FF            111   
00FF            112   power0: ; called from states
00FF C295       113       clr OUTPUT_PIN
0101 22         114       ret
0102            115   power20: ; called from states
0102 7538C8     116       mov desired_PWM+0, #low(200)  ;20% power
0105 753900     117       mov desired_PWM+1, #high(200)
0108 22         118       ret
0109            119   power100: ; called from states
0109 D295       120       setb OUTPUT_PIN
010B 22         121       ret
010C            122   
010C            123   Timer2_Init:
010C 75C800     124            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
010F 75CDBF     125            mov TH2, #high(TIMER2_RELOAD)
0112 75CC28     126            mov TL2, #low(TIMER2_RELOAD)
0115            127            ; Set the reload value
0115 43C980     128            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0118 75CBBF     129            mov RCMP2H, #high(TIMER2_RELOAD)
011B 75CA28     130            mov RCMP2L, #low(TIMER2_RELOAD)
011E            131            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
011E E4         132            clr a
011F F530       133            mov Count1ms+0, a
0121 F531       134            mov Count1ms+1, a
0123            135            ; Enable the timer and interrupts
0123 439B80     136            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
0126 D2CA       137       setb TR2  ; 
0128 22         138            ret
0129            139   
0129            140       
0129            141   
0129            142   ;---------------------------------;
0129            143   ; ISR for timer 2                 ;
0129            144   ;---------------------------------;
0129            145   Timer2_ISR:
0129 C2CF       146            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
012B            147            
012B            148            ; The two registers used in the ISR must be saved in the stack
012B C0E0       149            push acc
012D C0D0       150            push psw
012F            151            
012F            152            ; Increment the 16-bit one mili second counter
012F 0530       153            inc Count1ms+0    ; Increment the low 8-bits first
0131 E530       154            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0133 7002       155            jnz Inc_Done
0135 0531       156            inc Count1ms+1
0137            157   
0137            158   Inc_Done:
0137 E536       159            mov a, timer_state
0139 B40103     160            cjne a, #0x01, continue; if in timer state, jump
013C 1200E6     161            lcall Inc_PWM
013F            162   continue:        
013F            163            ; Check if half second has passed
013F E530       164            mov a, Count1ms+0
0141 B4E82E     165            cjne a, #low(1000), Timer2_ISR_done 
0144 E531       166            mov a, Count1ms+1
0146 B40329     167            cjne a, #high(1000), Timer2_ISR_done
0149            168            
0149            169   
0149 E4         170            clr a
014A F530       171            mov Count1ms+0, a
014C F531       172            mov Count1ms+1, a
014E            173            ; Increment the BCD counter
014E E532       174            mov a, BCD_counter
0150 2401       175            add a, #0x01
0152 D4         176            da a
0153 F532       177            mov BCD_counter, a
0155            178       
0155 F532       179       mov BCD_counter, a
0157 B53518     180            cjne a, Resulting_Counter, Timer2_ISR_done ; IF Resulting_counter is not BCD_counter, then skip
015A E536       181            mov a, timer_state
015C B40113     182       cjne a, #0x01, Timer2_ISR_done; if we are NOT in a timer state, jump to ISR_done
015F            183   
015F            184            ; IF STATE 1, then check 
015F E533       185            mov a, STATE_NUM
0161 B40109     186            cjne a, #0x01, OtherStates ; if STATE_NUM is NOT 1, jump
0164            187            ; CHECK if temperature is LESS than 50
0164 753300     188            mov STATE_NUM, #0x00
0167 753200     189            mov BCD_counter, #0x00
016A 020172     190            ljmp Timer2_ISR_done
016D            191   OtherStates:
016D 753200     192            mov BCD_counter, #0x00
0170 0533       193            inc STATE_NUM   ; increment state
0172            194   Timer2_ISR_done:
0172            195   
0172            196   
0172 D0D0       197            pop psw
0174 D0E0       198            pop acc
0176 32         199            reti
0177            200   
0177            201   LCD:
0177 C0E0       202            push acc
0179 7405       202            mov a, #5
017B 14         202            dec a
017C 1200C5     202            lcall ?Set_Cursor_2 ; Select column and row
017F D0E0       202            pop acc
0181 C000       203            push ar0
0183 A835       203            mov r0, Resulting_Counter
0185 1200CC     203            lcall ?Display_BCD
0188 D000       203            pop ar0
018A C0E0       204            push acc
018C 7401       204            mov a, #1
018E 14         204            dec a
018F 1200C5     204            lcall ?Set_Cursor_2 ; Select column and row
0192 D0E0       204            pop acc
0194 C000       205            push ar0
0196 A832       205            mov r0, BCD_counter
0198 1200CC     205            lcall ?Display_BCD
019B D000       205            pop ar0
019D C0E0       206            push acc
019F 7401       206            mov a, #1
01A1 14         206            dec a
01A2 1200C7     206            lcall ?Set_Cursor_1 ; Select column and row
01A5 D0E0       206            pop acc
01A7 C000       207            push ar0
01A9 A833       207            mov r0, STATE_NUM
01AB 1200CC     207            lcall ?Display_BCD
01AE D000       207            pop ar0
01B0 22         208       ret
01B1            209   
01B1            210   
01B1            211   
01B1            212            ; PROBLEM, 1ms uses TIMER 0
01B1            213   Wait50milliSec:
01B1 7A0A       214       mov R2, #10
01B3 79C8       215   W3: mov R1, #200
01B5 7868       216   W2: mov R0, #104
01B7 D8FE       217   W1: djnz R0, W1 ; 4 cycles->4*60.285ns*104=25us
01B9 D9FA       218       djnz R1, W2 ; 25us*200=5.0ms
01BB DAF6       219       djnz R2, W3 ; 5.0ms*10=50ms (approximately)
01BD 22         220       ret
01BE            221   
01BE            222   StateChanges: ; checks what will be the counter number for each state
01BE E533       223            mov a, STATE_NUM
01C0 B40006     224            cjne a, #0x00, next1 ; if STATE_NUM is NOT 0, jump to next1
01C3            225            
01C3 1201F9     226            lcall state0
01C6 0201F8     227            ljmp done_state_counter
01C9            228   next1:
01C9 E533       229            mov a, STATE_NUM
01CB B40106     230            cjne a, #0x01, next2 ; if STATE_NUM is NOT 1, jump to next2
01CE            231   
01CE 120214     232            lcall state1
01D1 0201F8     233            ljmp done_state_counter
01D4            234   next2:
01D4 E533       235            mov a, STATE_NUM
01D6 B40206     236            cjne a, #0x02, next3 ; if STATE_NUM is NOT 2, jump to next3
01D9            237            
01D9 12022F     238            lcall state2
01DC 0201F8     239            ljmp done_state_counter
01DF            240   next3:
01DF E533       241            mov a, STATE_NUM
01E1 B40306     242            cjne a, #0x03, next4 ; if STATE_NUM is NOT 3, jump to next4
01E4            243   
01E4 120245     244            lcall state3
01E7 0201F8     245            ljmp done_state_counter
01EA            246   next4:
01EA E533       247            mov a, STATE_NUM
01EC B40406     248            cjne a, #0x04, next5 ; if STATE_NUM is NOT 4, jump to next5
01EF            249   
01EF 120263     250            lcall state4
01F2 0201F8     251            ljmp done_state_counter
01F5            252   next5:
01F5 120279     253            lcall state5
01F8            254            ; STATE 5
01F8            255            
01F8            256   done_state_counter:
01F8 22         257            ret
01F9            258   
01F9            259   
01F9            260   
01F9            261   
01F9            262   
01F9            263   state0:
01F9 753600     264       mov timer_state, #0x00
01FC 1200FF     265       lcall power0
01FF 209711     266            jb START_BUTTON, quit0 ; if START BUTTON is NOT PRESSED
0202 1201B1     267            lcall Wait50milliSec
0205 20970B     268            jb START_BUTTON, quit0
0208            269   
0208 3097FD     270            jnb START_BUTTON, $ ; if START BUTTON is PRESSED go to state1
020B 753200     271            mov BCD_counter, #0x00
020E 753560     272            mov Resulting_Counter, #0x60
0211 0533       273            inc STATE_NUM
0213            274   quit0:
0213 22         275            ret
0214            276   state1:
0214 753601     277       mov timer_state, #0x01
0217 120109     278       lcall power100
021A 209711     279            jb START_BUTTON, quit1 ; if START BUTTON is NOT PRESSED
021D 1201B1     280            lcall Wait50milliSec
0220 20970B     281            jb START_BUTTON, quit1
0223            282   
0223 3097FD     283            jnb START_BUTTON, $ ; if START BUTTON is PRESSED go to state1
0226            284            ; IF TEMPERATURE is 150, 
0226            285       
0226 753200     286            mov BCD_counter, #0x00
0229 753506     287            mov Resulting_Counter, #0x06
022C 0533       288            inc STATE_NUM
022E            289   quit1:
022E 22         290            ret 
022F            291            
022F            292   state2:
022F 120102     293       lcall power20
0232 753601     294       mov timer_state, #0x01
0235 20970C     295       jb START_BUTTON, quit2 ; if START BUTTON is NOT PRESSED
0238 1201B1     296            lcall Wait50milliSec
023B 209706     297            jb START_BUTTON, quit2
023E            298   
023E 3097FD     299            jnb START_BUTTON, $ ; if START BUTTON is PRESSED go to state1
0241 753600     300       mov timer_state, #0x00
0244            301   quit2:
0244 22         302            ret
0245            303   
0245            304   state3:
0245 120109     305       lcall power100
0248 753600     306       mov timer_state, #0x00
024B 209714     307       jb START_BUTTON, quit3 ; if START BUTTON is NOT PRESSED
024E 1201B1     308            lcall Wait50milliSec
0251 20970E     309            jb START_BUTTON, quit3
0254            310   
0254 3097FD     311            jnb START_BUTTON, $ ; if START BUTTON is PRESSED go to state1
0257            312            ; IF TEMPERATURE REACHES RIGHT VALUE
0257 753601     313       mov timer_state, #0x01
025A 753200     314            mov BCD_counter, #0x00
025D 753507     315            mov Resulting_Counter, #0x07
0260 0533       316            inc STATE_NUM
0262            317   quit3:
0262 22         318            ret
0263            319   
0263            320   state4:
0263 120102     321       lcall power20
0266 753601     322       mov timer_state, #0x01
0269 20970C     323       jb START_BUTTON, quit4 ; if START BUTTON is NOT PRESSED
026C 1201B1     324            lcall Wait50milliSec
026F 209706     325            jb START_BUTTON, quit4
0272            326   
0272 3097FD     327            jnb START_BUTTON, $ ; if START BUTTON is PRESSED go to state1
0275 753200     328            mov BCD_counter, #0x00
0278            329   quit4:
0278 22         330            ret
0279            331   state5:
0279 1200FF     332       lcall power0
027C 753600     333       mov timer_state, #0x00
027F 20970F     334       jb START_BUTTON, quit5 ; if START BUTTON is NOT PRESSED
0282 1201B1     335            lcall Wait50milliSec
0285 209709     336            jb START_BUTTON, quit5
0288            337   
0288 3097FD     338            jnb START_BUTTON, $ ; if START BUTTON is PRESSED go to state1
028B            339            ; CHECK IF TEMPERATURE REACHES VERY LOW VALUE
028B 753300     340            mov STATE_NUM, #0x00
028E 753200     341            mov BCD_counter, #0x00
0291            342   quit5:
0291 22         343            ret
0292            344   
0292            345   FSM_main:
0292 75817F     346       mov SP, #0x7F
0295            347       
0295 75B100     348       mov P0M1, #0x00
0298 75B200     349       mov P0M2, #0x00
029B 75B300     350       mov P1M1, #0x00
029E 75B400     351       mov P1M2, #0x00
02A1 75AD00     352       mov P3M2, #0x00
02A4 75AD00     353       mov P3M2, #0x00
02A7            354       
02A7            355       
02A7            356       
02A7            357       
02A7 753200     358            mov BCD_counter, #0x00
02AA 753300     359            mov STATE_NUM, #0x00
02AD 753500     360            mov Resulting_Counter, #0x00
02B0            361   
02B0 120087     362       lcall LCD_4BIT
02B3 1200E2     363       lcall PWM_main
02B6 12010C     364            lcall Timer2_Init
02B9 D2AF       365       setb EA   ; Enable Global interrupts
02BB            366   FSM_forever:
02BB            367   
02BB 120177     368            lcall LCD
02BE 1201BE     369            lcall StateChanges
02C1            370            
02C1            371            
02C1            372       
02C1            373   
02C1 0202BB     374            ljmp FSM_forever
02C4            375   
02C4            376   
02C4            377   ; 
02C4            378   END
